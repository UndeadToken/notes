Some vulnerabilities allow users to input encoded characters that have special
meanings in HTML and HTTP responses. Normally applications sanitize these
characters when they are included in user input to prevent attackers from
maliciously manipulating HTTP messages, but in some cases applications either
forget to sanitize input or fail to do so properly.

When this happens servers, proxies and browsers may interpret the special
characters as code and alter the original HTTP message, allowing attackers to
manipulate an applications behaviour.

Two examples of encoded characters are %0D and %0A which represent \n (a carriage return)
and \r (a line feed). These encoded characters are commonly referred to as carriage
return line feeds (CRLF's). Servers and browsers rely on CRLF characters to
identify sections of HTTP messages, such as headers.

# HTTP Request Smuggling
HTTP request smuggling occurrs when an attacker exploits a CRLF injection
vulnerability to append a second HTTP request to the initial, legitimate request.

- In cache poisoning an attacker can change entries in an applications
  cache and serve malicious pages instead of a proper page.

- Firewall evasion occurs when a request is crafted using CRLFs to avoid
  security checks.

- In a request hijacking situation an attacker can steal httponly cookies and
  HTTP authentication information with no interaction between the attacker and
  client.

- HTTP response splitting allows an attacker to split a single HTTP response by
  injecting new headers that browsers interpret.

  %0d%0aContent-Length:%200%0d%0a%0d%0aHTTP/1.1%20%200%20OK%0d%0aContent-Type:%20
  text/html%0d%0aContent-Length:%2019%0d%0a%0d%0a<html>deface</html>

  Linefeed + unicode character (multi-byte characters)
  The unicode character is dropped leaving the line feed and carriage return.
  LF hex U+560A (56 0A) as UTF-8 %E5%98%8A
  CR hex U+560D (56 0D) as UTF-8 %E5%98%8D
  %E5%98%8A%E5%98%8DSet-Cookie:%20test
  https://foo.com/%E5%98%8A%E5%98%8DSet-Cookie:%20test
