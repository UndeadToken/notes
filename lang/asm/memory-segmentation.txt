A compiled programs memory is divided into five segments:
text; data, bss, heap and stack.

The text segment is also called the code segment. This is 
where the assembled machine language instructions of the 
program are located. Write permission is disabled in the
text segment, as it is not used to store variables, only 
code.

The data and bss segments are used to store global and 
static program variables. The data segment is filled with
the initialized global and static variables, while the bss
segment is filled with their uninitialized counterparts.
Although these segments are writable, they have a fixed 
size.

The heap memory segment is a segment of memory a programmer
can directly control. Blocks of memory in this segment can
be allocated and used for whatever the programmer might 
need. The heap is not of fixed size. The growth of the heap
moves downward toward higher memory addresses.

The stack segment also has variable size and is used as a
temporary scratch pad to store local function variables and
context during function calls.

The stack is comprised of many stack frames, which are made 
up of function variables and context. It is an abstract data
structure that is used frequently that follows a FILO (
first-in last-out) ordering. The ESP register is
used to keep track of the last address on the stack. In
contrast to the heap, the stack grows upward toward lower
memory addresses. When a function is called several things
are pushed to the stack together in a stack frame. The EBP
register-sometimes called the frame pointer or local base 
(LB) pointer is used to reference local function variables
in the current stack frame. Each stack frame contains the 
parameters to the function, its local variables and two
pointers that are necessary to put things back the way they
were: The saved frame pointer (SFP) and the return address.
The SFP is used to restore the EBP to its previous value
and the return address is used to restore EIP to the next
instruction found after the function call, this restores
the functional context of the previous stack frame.

The first few instructions of each function set up the stack
frame. These instructions are collectively called the
procedure prologue or function prologue. They save the
frame pointer on the stack and they save stack memory for
local function variables. Sometimes the function prologue
will handle stack alignment aswell. After the execution
finishes, the entire stack frame is popped off the stack
and the EIP is set to return to the return address so the
program can continue execution. If another functin was called
within the function another stack frame would be pushed
onto the stack and so on.

If static or global variables are initialized with data they
are stored in the data segment, otherwise they are stored 
in the bss segment.

Processor:
1. Reads the instruction that EIP is pointing to.
2. Adds the byte length of the instruction to EIP.
3. Executes the instruction that was read in step 1.
4. Goes back to step 1.

Low addresses    | Text (code) segment |
                 | Data Segment        |
                 | bss segment         |
                 | Heap segment        | The heap grows downward toward higher memory addresses.
High addresses   | Stack segment       | The stack grows upward toward loser memory addresses.

