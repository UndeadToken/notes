# Cluster
A cluster is a collection of hosts storage and networking resources that Kubernetes
use to run various workloads that comprise your system.

# Node
A node is a single host. Its job is to run pods. Each Kubernetes node runs several
Kubernetes components, such as a Kublet and a kube proxy. Nodes are managed by
Kubernetes master, The nodes are worker bees fof Kubernetes and shoulder all the
heavy lifting.

# Master
The master is the control plane of Kubernetes. It consists of several components,
such as an API server, a schedular, and a controller manager. The master is
responsible for the global, cluster-level scheduling of pods and handling of events.
Usually all the master components are setup on a single host.

# Pod
A pod is the unit of work in Kubernetes. Each pod contains one or more containers.
Pods are always scheduled together (always run on the same machine). All the
containers in the pod have the same IP address and port space; they can communicate
using localhost or standard inter-process communication. All the containers in the
pod have access to shared local storage on the node hosting the pod. The shared
storage will be mounted on each container.

# Label
Labels are key-value pairs that are used to group together sets of objects, very
often pods.

# Annotation
Annotations let you associate arbitrary metadata with Kubernetes objects.

# Label selectors
Label selectors are used to select objects based on their labels.
role = webserver
role = webserver, application != foo
role in (webserver, backend)

# Replication controller and replica set
Replication controllers and replica sets both manage a group of pods identified
by a label selector and ensure that a certain number is always up and running.
The main difference between them is that replication controllers test for
membership by name equality and replica sets can use set-based selection. Replica
sets are newer and designated as the next-generation replication controllers.

# Services
Services are used to expose some functionality to users or other services. They
usually encompass a group of pods, usually identified by labels. Services
operate at layer 3 (TCP/UDP). Kubernetes 1.2 added the Ingress object, which
provides access to HTTP objects. Services are published or discovered by either
DNS or environment variables.

# Volume
Local storage on the pod is ephemeral and goes away with the pod.
- emptydir: mounts a volume on each container which is backed by default by whatever
  is available on the hosting machine. The storage is deleted when the pod is
  terminated for any reason.
- persistentDiskClaim: abstracts a little bit and uses the default persistent
  storage in your environment (typically in a cloud provider).

# StatefulSet
Stateful sets ensure that a given number of pets with unique identities are running
at any given time. Stateful sets can help with peer discovery as well as adding
or removing pets. Pets have the following properties:
- A stable hostname, available in DNS
- An ordinal index
- Stable storage linked to the ordinal and hostname

# Secret
Secrets are small objects that contain sensitive info such as credentials and tokens.
They are stored as plaintext in etcd, accessible by the Kubernetes API server and
can be mounted as files into pods (using dedicated secret volumes that piggyback
on regular data volumes) that need to access them. The same secret can be
mounted on multiple pods. Kubernetes itself creates secrets for its components
and you can create your own secrets. Another approach is to use secrets as
environment variables. Secrets in a pod are always stored in
memory (tmpfs in the case of mounted secrets) for better security.

# Name
Each object in Kubernetes is identified by a UID and a name. The name is used to
refer to the object in API calls. UID's must be unique are generated by Kubernetes.

# Namespace
A namespace is a virtual cluster. You can have a single physical cluster that
contains multiple virtual clusters segregated by namespaces. Each virtual
cluster is totally isolated from other virtual clusters and they can only
communicate through public interfaces. Node objects and persistent volumes
dont live in a namespace. Kubernetes may schedule different namespaces to run on
the same node. Pods from different namespaces can use the same persistent storage.
